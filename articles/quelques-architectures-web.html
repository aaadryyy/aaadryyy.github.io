<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles/articles/default-layout.css"
    />
    <link rel="stylesheet" type="text/css" href="../styles/main.css" />
    <title>WIP - MPA / PEMPA / SPA...</title>
  </head>
  <body>
    <main>
      <article>
        <section class="section-title">
          <a href="../index.html">Retour</a>
          <h1 class="title">WIP - MPA / PEMPA / SPA / SSR / WTF</h1>
        </section>

        <!-- STATIQUE -->
        <section>
          <hr />
          <h2>
            <mark>1990's</mark>
            Site statique
          </h2>
          <p>
            Tout d'abord, un site est un ensemble de pages (= des documents html
            ou xhtml) rassemblées sous un même nom de domaine et accessibles via
            une connection internet.
          </p>
          <p>
            Un site est dit "statique" lorsque l'ensemble de ces pages ont été
            codés <em>"à la main"</em> sans aucune notion de données dynamiques.
            Concrètement, les pages sont enregistrées dans le serveur et
            distribuées telles quelles aux utilisteurs.
          </p>
          <p>
            Les utilisateurs se connectant à ce site vont donc tous voir
            exactement la même chose: les mêmes documents html.
          </p>
          <p>
            À la naissance du premier site web le 6 août 1991, c'était la seule
            option pour créer un site.
          </p>
          <h4>Premier chargement</h4>
          <img src="https://placehold.co/600x400" />
          <ol>
            <li>
              L’utilisateur écrit une URL dans la barre d’adresse (à la main ou
              via un lien)
            </li>
            <li>Le navigateur envoi une requête GET au serveur</li>
            <li>
              le serveur renvoi un des documents html qu'il a en mêmoire
              correspondant à l'url tapée par le client
            </li>
            <li>le navigateur affiche le document html reçu</li>
            <li>
              si nécessaire, le navigateur refait des requêtes au serveur pour
              récupérer les feuilles de style css et les scripts javascripts
            </li>
          </ol>
          <h4>Navigation</h4>
          <img src="https://placehold.co/600x400" />
          <ol>
            <li>
              L’utilisateur clique sur un lien hypertexte (une ancre
              <code>&lt;a /&gt;</code> ayant un href)
            </li>
            <li>Le navigateur envoi une requête GET au serveur</li>
            <li>
              le serveur renvoi un des documents html qu'il a en mêmoire
              correspondant à l'url accédée par le client
            </li>
            <li>le navigateur affiche le document html reçu</li>
            <li>
              si nécessaire, le navigateur refait des requêtes au serveur pour
              récupérer les feuilles de style css et les scripts javascripts
            </li>
          </ol>
          <h4>Formulaire</h4>
          <img src="https://placehold.co/600x400" />
          <ol>
            <li>L’utilisateur valide le formulaire</li>
            <li>
              Le navigateur envoi au serveur une requête POST ou PUT avec les
              informations du formulaire
            </li>
            <li>
              Le serveur crée ou modifie la data et la fait persister en base de
              donnée
            </li>
            <li>Le serveur renvoi un redirection</li>
            <li>
              Le client est redirigé vers une nouvelle URL et le navigateur
              lance une requête GET comme pour une navigation classique.
            </li>
          </ol>
          <h4>Les avantages</h4>
          <ul>
            <li>Les pages sont rapides à charger</li>
            <li>Le schéma mental est facile à retenir pour développeur</li>
          </ul>
          <h4>Les inconvénients</h4>
          <p>
            L'UX est très limitée par le rechargement global de la plage à
            chaque action impliquant le serveur.
          </p>
        </section>

        <!-- MPA -->
        <section>
          <hr />
          <h2>
            <mark>1990's</mark>
            MPA - Multi-Pages Application
          </h2>
          <p>Le site web <em>classique.</em></p>
          <p>Au commencement c'était la seule architecture possible.</p>
          <p>
            C'est un ensemble de pages (= des documents html ou xhtml)
            rassemblés sous un même nom de domaine et accessibles via une
            connection internet.
          </p>
          <p>Ici, tout le code réside côté serveur.</p>
          <h4>Premier chargement</h4>
          <img src="https://placehold.co/600x400" />
          <ol>
            <li>
              L’utilisateur écrit une URL dans la barre d’adresse (à la main ou
              via un lien)
            </li>
            <li>le client (= navigateur) envoi une requête au serveur</li>
            <li>
              le serveur renvoi un document html au client qui va l’afficher
            </li>
          </ol>
          <h4>Navigation</h4>
          <img src="https://placehold.co/600x400" />
          <h4>Formulaire</h4>
          <img src="https://placehold.co/600x400" />
          <ol>
            <li>L’utilisateur valide le formulaire</li>
            <li>
              Le navigateur envoi les informations du formulaire au serveur
            </li>
            <li>
              Le serveur crée ou modifie la data et la fait persister en base de
              donnée
            </li>
            <li>Le serveur renvoi un redirection</li>
            <li>
              Le client est redirigé vers une nouvelle URL et fait une requête
              GET comme précédemment.
            </li>
          </ol>
          <h4>Les +</h4>
          <ul>
            <li>C'est simple</li>
            <li>C'est rapide</li>
          </ul>
          <h4>Les -</h4>
          <ul>
            <li>Chaque interaction rafraîchit la page entièrement.</li>
            <li>(Quasiment) aucun feedback d’UI: pas d’état de chargement.</li>
          </ul>
        </section>

        <!-- PEMPA -->
        <section>
          <hr />
          <h2>
            <mark>2000's</mark>
            PEMPA - Progressive Enhanced Multi-Pages Application
          </h2>
          <p>
            Les années suivant la création du web ont vu
            <a
              href="https://upload.wikimedia.org/wikipedia/commons/7/74/Timeline_of_web_browsers.svg"
              target="_blank"
              rel="noreferrer"
              >l’émergence d’une multitude de navigateurs.</a
            >
          </p>
          <p>
            Les développeurs ont donc dû adapter leur site web à chaque
            navigateur, ayant souvent leur spécificités.
          </p>
          <p>
            C’est ainsi qu’est née l’idée de de l’<em
              >Amélioration Progressive</em
            >
            : avoir une MPA fonctionnelle et accessible sur tous les navigateurs
            tout en utilisant les particularités de chacun pour améliorer
            l’expérience utilisateur.
          </p>
          <p>
            C’est aussi à la même période qu’AJAX apparait: plus besoin alors de
            faire appel au serveur pour la moindre petite interaction (en tout
            cas sur certains navigateurs) !
          </p>
          <h4>Premier chargement</h4>
          <p>
            Exactement le même comportement qu’une MPA classique : le navigateur
            requête un document qui est renvoyé par le serveur.
          </p>
          <h4>Navigation côté client</h4>
          <ol>
            <li>Un utilisateur clique sur un lien ayant un href</li>
            <li>
              Le code écrit côté client va empêcher le comportement par défaut
              du navigateur (la requête au serveur et le rafraîchissement de la
              page). Toutes ces actions sont donc faites manuellement à la place
              du navigateur :
            </li>
            <ol>
              <li>L’URL est mise à jour</li>
              <li>La requête au serveur pour récupérer les données</li>
              <li>Puis la mise à jour des données dans le navigateur</li>
            </ol>
          </ol>
          <h4>Formulaire</h4>
          <ol>
            <li>
              Lorsqu’un utilisateur envoi un formulaire, de nouveau le code va
              empêcher le comportement par défaut du navigateur (un POST et un
              rafraîchissement complet de la page)
            </li>
            <li>Javascript va envoyer la donnée du formulaire au serveur</li>
            <li>
              Le serveur va renvoyer les données adéquates qui vont mettre à
              jour les données côté client.
            </li>
          </ol>
          <h4>Les +</h4>
          <ul>
            <li>Le problème de rafraîchissement des pages est résolu</li>
            <li>
              Plus généralement, un gain de contrôle côté client pour une
              meilleure expérience utilisateur
            </li>
          </ul>
          <h4>Les -</h4>
          <ul>
            <li>
              On doit simuler le comportement des navigateurs, ce qui rajoute
              une couche de complexité : routing, form submission, garder la
              data à jour côté front…
            </li>
            <li>Bien plus de code à gérer, et donc bien plus de bug</li>
            <li>
              Énormément de code est dupliqué depuis le back car tous les
              navigateurs ne géraient pas forcément AJAX. Il faut donc s’assurer
              que la version MPA fonctionne toujours, tout en dupliquant
              beaucoup de code côté front au cas ou le navigateur serait assez
              puissant.
            </li>
            <li>L’organisation du code devient plus complexe</li>
            <li>
              La synchronisation Serveur/Navigateur manque de clarté. Ce qui est
              mis à jour d’un côté doit l’être de l’autre et inversement.
            </li>
          </ul>
        </section>

        <!-- SPA -->
        <section>
          <hr />
          <h2>
            <mark>2010's</mark>
            SPA - Single Page Application
          </h2>
          <p><em>Application à page unique</em></p>
          <p>
            Tout le code originellement dupliqué côté backend a été rapatrié
            côté client, notamment tout le rendu de l’UI au profit de simples
            routes API qui renvoient du JSON.
          </p>
          <h4>Premier chargement</h4>
          <h4>Navigation</h4>
          <ol>
            <li>
              L’utilisateur écrit une URL dans la barre d’adresse (à la main ou
              via un lien)
            </li>
            <li>le client (= navigateur) envoi une requête au serveur</li>
            <li>
              le serveur renvoi un document html au client qui va l’afficher
            </li>
            <li>
              L’on va ensuite télécharger le Javascript (sauf dans le cas des
              SSG pour les pages statiques)
            </li>
            <li>Et une fois l’UI rendue, on va fetch les données</li>
          </ol>
          <h4>Formulaire</h4>
          <p>La même chose que les PEMPAs</p>
          <h4>Les +</h4>
          <ul>
            <li>La DX !</li>
          </ul>
          <h4>Les -</h4>
          <ul>
            <li>
              La requête initiale est encore pire, avec ses successions de
              requêtes serveur pour afficher la donnée
            </li>
            <li>
              La SEO en est donc affectée si on ne met pas en place de la SSG
              (Server Side Generation) pour les pages statiques.
            </li>
            <li>La taille du bundle a explosé, ce qui a miné la performance</li>
            <li>
              Les cascades : document → app.js → page.js → component.js →
              data.json → image.png.
            </li>
            <li>
              La gestion du state s’est complexifié. Auparavant, le DOM était le
              state. Maintenant il faut écrire une grosse quantité de code pour
              gérer les différents states de l’app.
            </li>
            <li>Javascript <em>Fatigue.</em></li>
          </ul>
        </section>
      </article>
    </main>
  </body>
</html>
